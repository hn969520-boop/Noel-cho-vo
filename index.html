<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<title>Hand Gesture Photo Orbit TikTok</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    font-family: system-ui, sans-serif;
  }
  #preview {
    position: fixed;
    bottom: 16px;
    right: 16px;
    width: 140px;
    height: 105px;
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid rgba(255,255,255,.6);
    box-shadow: 0 0 20px rgba(0,255,255,.6);
    z-index: 10;
  }
  #preview canvas {
    width: 100%;
    height: 100%;
  }
  #hud {
    position: fixed;
    top: 14px;
    left: 50%;
    transform: translateX(-50%);
    color: #0ff;
    font-weight: 600;
    letter-spacing: 1px;
    text-shadow: 0 0 12px #0ff;
    z-index: 10;
  }
</style>
</head>

<body>

<div id="hud">GESTURE READY</div>
<div id="preview"><canvas id="cam"></canvas></div>

<!-- THREE -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

<!-- BLOOM -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<!-- MEDIAPIPE -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ===================== BASIC THREE ===================== */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ===================== BLOOM ===================== */
const composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));

const bloom = new THREE.UnrealBloomPass(
  new THREE.Vector2(innerWidth, innerHeight),
  1.2, 0.6, 0.15
);
composer.addPass(bloom);

/* ===================== LIGHT ===================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 1);
dir.position.set(5,5,5);
scene.add(dir);

/* ===================== STATE ===================== */
let state = "TREE"; // TREE | EXPLODE | PHOTO
let selectedIndex = 0;

/* ===================== HAND ===================== */
let handX = 0, handY = 0;
let smoothX = 0, smoothY = 0;
let isPinching = false;

/* ===================== ORBIT CONTROL ===================== */
let orbitAngle = 0;
let orbitVel = 0;
let lastHandX = 0;
const ROT_SENS = 3.0;
const ROT_DAMP = 0.86;

/* pinch step */
let pinchHoldX = null;
let lastStepTime = 0;
const STEP_COOLDOWN = 220;

/* ===================== PARTICLE TREE ===================== */
const pGeo = new THREE.BufferGeometry();
const pCount = 1200;
const pPos = new Float32Array(pCount * 3);

for (let i = 0; i < pCount; i++) {
  const h = Math.random();
  const r = h * 1.2;
  const a = Math.random() * Math.PI * 2;
  pPos[i*3] = Math.cos(a) * r;
  pPos[i*3+1] = h * 2 - 1;
  pPos[i*3+2] = Math.sin(a) * r;
}

pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
const pMat = new THREE.PointsMaterial({
  color: 0x00ffff,
  size: 0.04,
  transparent: true
});
const tree = new THREE.Points(pGeo, pMat);
scene.add(tree);

/* ===================== PHOTOS ===================== */
const photos = [];
const loader = new THREE.TextureLoader();
const urls = ["1.jpeg","2.jpeg","3.jpeg","4.jpeg","5.jpeg"];

urls.forEach((u,i)=>{
  const m = new THREE.Mesh(
    new THREE.PlaneGeometry(1,1.2),
    new THREE.MeshStandardMaterial({
      map: loader.load(u),
      transparent:true
    })
  );
  m.visible = false;
  scene.add(m);
  photos.push(m);
});

/* ===================== HELPERS ===================== */
function snapOrbit() {
  const step = Math.PI * 2 / photos.length;
  const snap = Math.round(orbitAngle / step) * step;
  orbitAngle = orbitAngle * 0.8 + snap * 0.2;
}

/* ===================== MEDIAPIPE ===================== */
const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});
hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});

hands.onResults(res=>{
  if (!res.multiHandLandmarks) return;

  const lm = res.multiHandLandmarks[0];
  const ix = lm[8], tx = lm[4];

  smoothX += ((ix.x - 0.5)*4 - smoothX) * 0.25;
  smoothY += (-(ix.y - 0.5)*3 - smoothY) * 0.25;
  handX = smoothX;
  handY = smoothY;

  const d = Math.hypot(ix.x - tx.x, ix.y - tx.y);
  isPinching = d < 0.045;

  // state
  if (isPinching && state === "EXPLODE") state = "PHOTO";
  else if (!isPinching && state === "TREE") state = "EXPLODE";

  // orbit drag
  const dx = handX - lastHandX;
  lastHandX = handX;

  if (state !== "TREE") {
    orbitVel += dx * ROT_SENS;
    orbitVel *= ROT_DAMP;
    orbitAngle += orbitVel;
  }

  if (state === "EXPLODE" && Math.abs(orbitVel) < 0.002) snapOrbit();

  // pinch swipe step
  const now = performance.now();
  if (state !== "TREE" && isPinching) {
    if (pinchHoldX === null) pinchHoldX = handX;
    const delta = handX - pinchHoldX;

    if (now - lastStepTime > STEP_COOLDOWN) {
      if (delta > 0.12) {
        selectedIndex = (selectedIndex + 1) % photos.length;
        pinchHoldX = handX;
        lastStepTime = now;
      } else if (delta < -0.12) {
        selectedIndex = (selectedIndex - 1 + photos.length) % photos.length;
        pinchHoldX = handX;
        lastStepTime = now;
      }
    }
  } else pinchHoldX = null;
});

/* ===================== CAMERA ===================== */
const video = document.createElement("video");
const cam = new Camera(video, {
  onFrame: async ()=> await hands.send({image:video}),
  width: 640,
  height: 480
});
cam.start();

/* ===================== LOOP ===================== */
function animate(){
  requestAnimationFrame(animate);

  tree.visible = state === "TREE";
  tree.rotation.y += 0.003;

  const step = Math.PI * 2 / photos.length;

  photos.forEach((m,i)=>{
    m.visible = state !== "TREE";

    const a = i*step + orbitAngle;
    const r = 1.5;

    m.position.set(
      handX + Math.cos(a)*r,
      handY + Math.sin(a)*r*0.6,
      Math.sin(a)
    );

    const front = i === selectedIndex;
    const s = front && state === "PHOTO" ? 2.6 : 1.0;
    m.scale.lerp(new THREE.Vector3(s,s,s),0.15);
    m.material.opacity = front || state==="EXPLODE" ? 1 : 0.15;
  });

  document.getElementById("hud").textContent =
    state==="TREE" ? "OPEN HAND" :
    state==="EXPLODE" ? "SWIPE TO SELECT" :
    "PINCH + SWIPE";

  composer.render();
}
animate();

window.onresize = ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
  composer.setSize(innerWidth,innerHeight);
};
</script>

</body>
</html>
